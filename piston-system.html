<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Piston System</title>
    <style>
      body {
        background: #0b1a2c;
        color: #e5e7eb;
      }

      canvas {
        border: 1px solid #1f2937;
        background-color: #111827;
      }
    </style>
  </head>
  <body>
    <!-- controls -->
    <div class="controls">
      <label for="volume">VOLUME</label>
      <input
        type="range"
        name="volume"
        id="volumeInput"
        min="50"
        max="700"
        value="300"
        oninput="volDisp.value = this.value"
      />
      <output id="volDisp">300</output> (*500 px^2)
      <label for="temperature">TEMPERATURE:</label>
      <input
        type="range"
        name="temperature"
        id="temperatureInput"
        min="273"
        max="1273"
        value="573"
        oninput="tempDisp.value = this.value"
      />
      <output id="tempDisp">573</output>K
      <label for="moles">moles</label>
      <input
        type="range"
        name="moles"
        id="molesInput"
        min="1"
        max="10"
        value="3"
      />
      <button id="pauseBtn">Resume</button>
      <button id="resetGraphBtn">Reset Graph</button>
      <p>Pressure: <span id="pressureDisplay">0</span></p>
    </div>
    <canvas id="simCanvas"></canvas>
    <canvas id="graphCanvas"></canvas>
  </body>

  <script>
    const simCanvas = document.getElementById("simCanvas");
    const ctx = simCanvas.getContext("2d");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetGraphBtn = document.getElementById("resetGraphBtn");
    let isPaused = true;
    // inputs
    const temperatureInput = document.getElementById("temperatureInput");
    const volumeInput = document.getElementById("volumeInput");
    const molesInput = document.getElementById("molesInput");

    simCanvas.width = 500;
    simCanvas.height = 700;

    let NUM_PARTICLES = parseInt(molesInput.value) * 100;
    const RADIUS = 2;
    const particles = [];
    let temp = parseInt(temperatureInput.value);
    let vol = parseInt(volumeInput.value);
    let pv_dataPoints = [];
    let accumulatedImpulse = 0;
    let smoothPressure = 0;

    const pi = Math.PI;

    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * simCanvas.width;
        this.y = simCanvas.height - vol + Math.random() * vol;

        const angle = Math.random() * 2 * pi;
        const speed = 0.25 * Math.sqrt(temp);

        this.vx = speed * Math.cos(angle);
        this.vy = speed * Math.sin(angle);
      }

      update() {
        this.x += parseFloat(this.vx);
        this.y += parseFloat(this.vy);

        if (this.x <= 0 || this.x >= simCanvas.width) {
          this.vx *= -1;
          // accumulatedImpulse += 2 * Math.abs(this.vx);
          // this pressure is almost constant
        }

        if (this.y <= simCanvas.height - vol || this.y >= simCanvas.height) {
          this.vy *= -1;
          accumulatedImpulse += 2 * Math.abs(this.vy);
        }

        // Inside update()
        if (this.x < RADIUS) this.x = RADIUS;
        if (this.x > simCanvas.width - RADIUS)
          this.x = simCanvas.width - RADIUS;
        if (this.y < simCanvas.height - vol + RADIUS)
          this.y = simCanvas.height - vol + RADIUS;
        if (this.y > simCanvas.height - RADIUS)
          this.y = simCanvas.height - RADIUS;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, RADIUS, 0, 2 * pi);
        ctx.fillStyle = "rgba(239, 68, 68, 0.7)"; // Red
        ctx.fill();
      }
    }

    pauseBtn.addEventListener("click", () => {
      if (isPaused) {
        isPaused = false;
        animate();
        pauseBtn.innerText = "Pause";
      } else {
        isPaused = true;
        pauseBtn.innerText = "Resume";
      }
    });

    resetGraphBtn.addEventListener("click", () => {
      pv_dataPoints = [];
    });

    function init() {
      for (let i = 0; i < NUM_PARTICLES; i++) {
        particle = new Particle();
        overlapping = false;
        for (let i = 0; i < particles.length; i++) {
          if (
            Math.abs(particles[i].x - particle.x) < RADIUS * 2 &&
            Math.abs(particles[i].y - particle.y) < RADIUS * 2
          ) {
            overlapping = true;
            break;
          }
        }
        if (overlapping) i--;
        else particles.push(particle);
      }
    }

    init();

    function handle_collision(p1, p2) {
      let dx = p1.x - p2.x;
      let dy = p1.y - p2.y;
      let distance = Math.sqrt(dx * dx + dy * dy);

      // If particles are exactly on top of each other
      if (distance === 0) {
        dx = Math.random() - 0.5;
        dy = Math.random() - 0.5;
        distance = Math.sqrt(dx * dx + dy * dy);
      }

      if (distance <= RADIUS * 2) {
        // get normal along collision
        const nx = dx / distance;
        const ny = dy / distance;

        const v1n = p1.vx * nx + p1.vy * ny; //resolve components
        const v2n = p2.vx * nx + p2.vy * ny;

        const impulse = v1n - v2n;

        p1.vx -= impulse * nx;
        p1.vy -= impulse * ny;
        p2.vx += impulse * nx;
        p2.vy += impulse * ny;

        // Correction (Prevent sticking)
        const overlap = RADIUS * 2 - distance;
        const correctionX = (overlap / 2) * nx;
        const correctionY = (overlap / 2) * ny;

        p1.x -= correctionX;
        p1.y -= correctionY;
        p2.x += correctionX;
        p2.y += correctionY;
      }
    }

    let frameCount = 0;
    const graphCanvas = document.getElementById("graphCanvas");
    const graphCtx = graphCanvas.getContext("2d");
    graphCanvas.width = 500;
    graphCanvas.height = 500;

    function map(value, inpMin, inpMax, outMin, outMax) {
      const factor = (outMax - outMin) / (inpMax - inpMin);
      return outMin + (value - inpMin) * factor;
    }

    function animate() {
      ctx.clearRect(0, 0, simCanvas.width, simCanvas.height);

      const newTemp = parseFloat(temperatureInput.value);
      if (newTemp != temp) {
        particles.forEach((particle) => {
          particle.vx *= Math.sqrt(newTemp) / Math.sqrt(temp);
          particle.vy *= Math.sqrt(newTemp) / Math.sqrt(temp);
        });
        temp = newTemp;
      }

      if (parseInt(volumeInput.value) != vol) {
        vol = parseInt(volumeInput.value);
        //push particles down
        particles.forEach((p) => {
          if (p.y < simCanvas.height - vol)
            p.y = simCanvas.height - vol + RADIUS + 1;
        });
      }

      // particle collision and update
      for (let i = 0; i < NUM_PARTICLES; i++) {
        let p = particles[i];

        for (let j = i + 1; j < NUM_PARTICLES; j++) {
          handle_collision(p, particles[j]);
        }

        p.update();
        p.draw();
      }

      frameCount++;

      if (frameCount % 5 == 0) {
        graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

        if (smoothPressure === 0) smoothPressure = accumulatedImpulse;
        else smoothPressure = 0.9 * smoothPressure + 0.1 * accumulatedImpulse;

        pv_dataPoints.push({ x: vol, y: smoothPressure });
        document.getElementById("pressureDisplay").innerText =
          accumulatedImpulse.toFixed(2);

        if (pv_dataPoints.length > 1) {
          graphCtx.beginPath();
          graphCtx.strokeStyle = "lime";
          graphCtx.lineWidth = 2;

          for (let i = 0; i < pv_dataPoints.length; i++) {
            let p = pv_dataPoints[i];

            let plotX = map(p.x, 50, 700, 0, graphCanvas.width);
            let plotY = map(p.y, 10, 1000, graphCanvas.height, 0);

            if (i === 0) graphCtx.moveTo(plotX, plotY);
            else graphCtx.lineTo(plotX, plotY);
          }
          graphCtx.stroke();
        }

        accumulatedImpulse = 0;
      }

      if (!isPaused) requestAnimationFrame(animate);
    }
  </script>
</html>
